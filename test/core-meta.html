<!doctype html>
<!--
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<html>
<head>

  <title>core-meta</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../simple-fixture/simple-fixture-mocha.js"></script>

  <link rel="import" href="../core-meta.html">
  <link rel="import" href="../../simple-fixture/simple-fixture.html">

</head>
<body>

  <simple-fixture id="TrivialMeta">
    <template>
      <core-meta id="info"></core-meta>
    </template>
  </simple-fixture>

  <simple-fixture id="ManyMetas">
    <template>
      <core-meta id="default1"></core-meta>
      <core-meta id="default2"></core-meta>
      <core-meta id="default3"></core-meta>
    </template>
  </simple-fixture>

  <simple-fixture id="DifferentTypedMetas">
    <template>
      <core-meta type="foo" key="foobarKey"></core-meta>
      <core-meta type="bar" key="foobarKey"></core-meta>
      <core-meta key="defaultKey"></core-meta>
    </template>
  </simple-fixture>

  <simple-fixture id="ClashingMetas">
    <template>
      <core-meta id="foo"></core-meta>
      <core-meta id="foo"></core-meta>
    </template>
    <template>
      <core-meta id="bar"></core-meta>
      <core-meta key="bar"></core-meta>
    </template>
    <template>
      <core-meta key="baz"></core-meta>
      <core-meta key="baz"></core-meta>
    </template>
  </simple-fixture>

  <script>
suite('<core-meta>', function () {
  suite('basic behavior', function () {
    var meta;

    setup(function () {
      meta = fixture('TrivialMeta');
    });

    teardown(function () {
      meta.unregisterSelf();
    });

    test('uses itself as the default value', function () {
      expect(meta.value).to.be.equal(meta);
    });

    test('will use id as its key by default', function () {
      expect(meta.key).to.be.equal(meta.id);
    });

    test('can be assigned alternative values', function () {
      meta.value = 'foobar';

      expect(meta.list[0]).to.be.equal('foobar');
    });

    test('can access same-type meta values by key', function () {
      expect(meta.byKey(meta.key)).to.be.equal(meta.value);
    });

    test('can by looked up "byId" as an alias for "byKey"', function () {
      expect(meta.byId('meta')).to.be.equal(meta.byKey('meta'));
    });

    test('yields a list of same-type meta data', function () {
      expect(meta.list).to.be.ok;
      expect(meta.list.length).to.be.equal(1);
      expect(meta.list[0]).to.be.equal(meta);
    });
  });

  suite('many same-typed metas', function () {
    var metas;

    setup(function () {
      metas = fixture('ManyMetas');
    });

    teardown(function () {
      metas.forEach(function (meta) {
        meta.unregisterSelf();
      });
    });

    test('all cache all meta values', function () {
      metas.forEach(function (meta, index) {
        expect(meta.list.length).to.be.equal(metas.length);
        expect(meta.list[index].value).to.be.equal(meta.value);
      });
    });

    test('can be unregistered individually', function () {
      metas[0].unregisterSelf();

      expect(metas[0].list.length).to.be.equal(2);
      expect(metas[0].list).to.be.deep.equal([metas[1], metas[2]])
    });

    test('can access each others value by key', function () {
      expect(metas[0].byKey('default2')).to.be.equal(metas[1].value);
    });
  });

  suite('different-typed metas', function () {
    var metas;

    setup(function () {
      metas = fixture('DifferentTypedMetas');
    });

    teardown(function () {
      metas.forEach(function (meta) {
        meta.unregisterSelf();
      });
    });

    test('cache their values separately', function () {
      var fooMeta = metas[0];
      var barMeta = metas[1];

      expect(fooMeta.value).to.not.be.equal(barMeta.value);
      expect(fooMeta.byKey('foobarKey')).to.be.equal(fooMeta.value);
      expect(barMeta.byKey('foobarKey')).to.be.equal(barMeta.value);
    });

    test('cannot access values of other types', function () {
      var defaultMeta = metas[2];

      expect(defaultMeta.byKey('foobarKey')).to.be.equal(undefined);
    });

    test('only list values of their type', function () {
      metas.forEach(function (meta) {
        expect(meta.list.length).to.be.equal(1);
        expect(meta.list[0]).to.be.equal(meta.value);
      })
    });
  });

  suite('metas with clashing keys', function () {
    var metaPairs;

    setup(function () {
      metaPairs = fixture('ClashingMetas');
    });

    test('let the last value win registration against the key', function () {
      metaPairs.forEach(function (metaPair) {
        var registeredValue = metaPair[0].byKey(metaPair[0].key);
        var firstValue = metaPair[0].value;
        var secondValue = metaPair[1].value;

        expect(registeredValue).to.not.be.equal(firstValue);
        expect(registeredValue).to.be.equal(secondValue);
      });
    });
  });
});
  </script>

</body>
</html>
